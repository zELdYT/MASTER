
/*
 * Copyright (c) 2024 zELdYT
 *
 * Licensed under the BSD 2-Clause License.
 * See the LICENSE file in the project root for more details.
 */

#ifndef __MASTER_SEDENION_INCLUDE_H__
#define __MASTER_SEDENION_INCLUDE_H__

#include <math.h> // sqrt

#define MASTER_SQUARE(x) (x*x)

#define __MASTER_MACROS_SEDENION_DEFINE_TYPE(type, prefix) \
typedef struct { \
	type rl; \
	type e[15]; \
} MASTER_sedenion##prefix; \
\
MASTER_sedenion##prefix \
MASTER_sedenion_toSedenion##prefix(type value) { \
	MASTER_sedenion##prefix __sedi; \
	__sedi.rl = value; \
	__sedi.e[0] = __sedi.e[1] = __sedi.e[2] = __sedi.e[3] = \
	__sedi.e[4] = __sedi.e[5] = __sedi.e[6] = __sedi.e[7] = \
	__sedi.e[8] = __sedi.e[9] = __sedi.e[10] = __sedi.e[11] = \
	__sedi.e[12] = __sedi.e[13] = __sedi.e[14] = 0; \
	return __sedi; } \
\
MASTER_sedenion##prefix \
MASTER_sedenion_add##prefix(const MASTER_sedenion##prefix * __sedi1, const MASTER_sedenion##prefix * __sedi2) { \
	MASTER_sedenion##prefix sedi; \
	sedi.rl = __sedi1->rl + __sedi2->rl; \
	unsigned char i = 0; \
	for (; i < 15; i++) \
		sedi.e[i] = __sedi1->e[i] + __sedi2->e[i]; \
	return sedi; } \
\
MASTER_sedenion##prefix \
MASTER_sedenion_sub##prefix(const MASTER_sedenion##prefix * __sedi1, const MASTER_sedenion##prefix * __sedi2) { \
	MASTER_sedenion##prefix sedi; \
	sedi.rl = __sedi1->rl - __sedi2->rl; \
	unsigned char i = 0; \
	for (; i < 15; i++) \
		sedi.e[i] = __sedi1->e[i] - __sedi2->e[i]; \
	return sedi; } \
\
MASTER_sedenion##prefix \
MASTER_sedenion_scalarmul##prefix(const MASTER_sedenion##prefix * __sedi1, const type scalar) { \
	MASTER_sedenion##prefix sedi; \
	sedi.rl = __sedi1->rl * scalar; \
	unsigned char i = 0; \
	for (; i < 15; i++) \
		sedi.e[i] = __sedi1->e[i] * scalar; \
	return sedi; } \
\
/* Next function generated by AI. I will multiply the sedenions myself */ \
MASTER_sedenion##prefix \
MASTER_sedenion_mul##prefix(const MASTER_sedenion##prefix *a, const MASTER_sedenion##prefix *b) { \
    MASTER_sedenion##prefix result; \
    type real_part = a->rl * b->rl; \
    type imag_parts[16] = {0}; \
	unsigned char i, j; \
    for (i = 0; i < 15; i++) real_part -= a->e[i] * b->e[i]; \
    result.rl = real_part; \
    for (i = 0; i < 15; i++) { \
        imag_parts[i] = a->rl * b->e[i] + b->rl * a->e[i]; \
        for (j = 0; j < 15; j++) if (j != i) imag_parts[i] += a->e[j] * b->e[(i + j) % 16]; \
        result.e[i] = imag_parts[i]; \
    } \
    return result; \
} \
\
MASTER_sedenion##prefix \
MASTER_sedenion_div##prefix(const MASTER_sedenion##prefix * __sedi1, const MASTER_sedenion##prefix * __sedi2) { \
	MASTER_sedenion##prefix sedi; \
	unsigned char i; \
	sedi.rl = __sedi2->rl; \
	for (i = 0; i < 15; i++) \
		sedi.e[i] = -__sedi2->e[i]; \
	sedi = MASTER_sedenion_mul##prefix(__sedi1, &sedi); \
	type delim = MASTER_SQUARE(sedi.rl); \
	for (i = 0; i < 15; i++) \
		delim += MASTER_SQUARE(sedi.e[i]); \
	sedi.rl = __sedi2->rl; \
	for (i = 0; i < 15; i++) \
		sedi.e[i] /= delim; \
	return sedi; } /* Teoretically & in my mind it need to work correctly */ \
\
type \
MASTER_sedenion_norm##prefix(const MASTER_sedenion##prefix * __sedi) { \
	double ext = 0; \
	unsigned char i = 0; \
	for (; i < 15; i++) \
		ext += MASTER_SQUARE(__sedi->e[i]); \
	return sqrt(MASTER_SQUARE(__sedi->rl) + ext); } \
\
MASTER_sedenion##prefix \
MASTER_sedenion_normalize##prefix(const MASTER_sedenion##prefix * __sedi) { \
	MASTER_sedenion##prefix sedi; \
	type delim = MASTER_sedenion_norm##prefix(__sedi); \
	sedi.rl = __sedi->rl / delim; \
	unsigned char i = 0; \
	for (; i < 15; i++) \
		sedi.e[i] = __sedi->e[i] / delim; \
	return sedi; }

__MASTER_MACROS_SEDENION_DEFINE_TYPE(char,        c)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(short,       s)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(long,        l)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(long long,   ll)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(float,       f)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(double,      d)
__MASTER_MACROS_SEDENION_DEFINE_TYPE(long double, ld)

#undef __MASTER_MACROS_SEDENION_DEFINE_TYPE

#endif /* __MASTER_SEDENION_INCLUDE_H__ */

// be master~
